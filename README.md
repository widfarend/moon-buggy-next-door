# Moon Buggy Next Door

Moon Buggy Next Door was created for a take-home programming assignment given by an awesome sounding company called Car Next Door. Below you will
find the following sections:

* Submission details, including frameworks, libraries etc, chosen and any justifications for choosing them. It also gives details
of any potential features and enhancements to both the application from a product and development perspective.
* Requirements -- the original requirements document supplied by CND.
* Running instructions -- I can't take credit for these as they were generated by Angular-CLI, however they are also true.

Click here for a live version --> [Moon Buggy Next Door](http://moonbuggynextdoor.herokuapp.com/) (`http://moonbuggynextdoor.herokuapp.com/`).

## Submission

Free reign was pretty much provided in terms of what front-end frameworks and/or libraries that could be used. This obviously presented a 
massive choice. These could have been from any of the following and more:

* Plain old Javascript, HTML and CSS
* Angular 1 (no, not really!)
* Angular 2/4/5 (what happened to 3?)
* React or Vue or Ember, etc
* The latest, brand-new Javascript framework that came out several hours ago

In the end I chose Angular 5 along with Tailwind CSS.

### Why Angular 5?

Angular 5 was a valid choice for a number of reasons:

* Provides everything needed out of the box.
* Tooling is mostly setup / boilerplate taken care of which, based on the short deadline, meant less time setting up
and more time actually developing a product.
* TypeScript classes and interfaces makes code more concise and easier to read and write.
* Clean separation between rendering code and application logic.
* Dependency injection -- clean way to implement loosely coupled components and services.
* Components! Easy to create reusable and loosely coupled components.
* Well defined component lifecycles.
* Unit and integration testing framework out of the box (it even generates the spec files when you generate a new 
component wih ng).
* Makes the app scalable -- can add more features easily in a well defined framework which provides the added benefit
of bringing new developers onto the team.
* Can also be used to turn the app into a mobile applications.
* My number one reason for using Angular 5? It's where I have most of my recent experience and, with the short time scale,
a familiar framework was a better option than attempting to learn something new or build my own from scratch (which has its own drawbacks).

### Why Tailwind CSS?

There were only a few reasons why I selected Tailwind:

* It let you throw together a respectable looking interface with little effort.
* Lets you componentise CSS objects which fits well with web components.
* Something quick and easy (kind of) to learn while working on a new project.
* CND are using it.

### Moon Buggy Next Door Web App

The app was broken up into a map component to provide the Google Maps experience (on the moon!), UI components to drive
the map, including entering a lat/long value in the form of a comma separated string, e.g. `'0.634, -12.1256'`, and by selecting
one of the lunar vehicles on the panel, and finally a HTTP service to retrieve the lunar vehicle data from a back end.

Some further variables, such as the base url to call the vehicle API, and the Car Next Door Lunar Command Centre (CNDLCC), were
placed in the environment configuration as a single place to add them.

The UI went through a few iterations where I finally settled on a side panel for medium plus sized screens that collapses into a
top menu for mobile devices. I reused the CND blue brand colour for the interface. The power bars on the vehicle cards are red, 
yellow or green depending on the value of the vehicle battery power. The map pointer icons are cartoon-like and were sourced
from the web, however they are configurable and can be changed easily as part of the branding.

### Enhancements

* One thing I wanted to add to the UI was a single box at the top for entering the latlong string and a button below it
that will slide down with the list of vehicles, converting the single floating box into a side menu. This can then be collapsed back
into a single box.

* I also wanted to have animated power bars that look a little more interesting than just plain coloured bars.

* I left a thin, blue bar on the interface where filter, sorting and other controls could be added.

### Further work

The application, from a functional perspective, fits with the requirements. However I would like to improve the interface,
especially the user experience, adding more animations to provide a slicker experience.

In terms of development, more coverage on the tests, including e2e which I didn't have the time to complete. Better testing
of the google maps components as currently I'm only testing the pure functions and not the map itself.

Branding and configuration improvements to enable white labelling and easy deployment to other environments.

Breaking down the components further as there were opportunities to do this, however due to time restrictions I kept some of the
components inline. An example being the vehicle cards in the sidebar. Off the back of this it would improve the structure the app in terms of directory structure
and ease of getting to the files/code you need to.

I initially pulled in the vehicle data and added the points to the map, the easiest way to do this was a forEach loop 
whereby I concat to an array which is passed as a property to the maps component. This then uses the OnChanges lifecycle hook
to add a pointer the map. The issue I had was this wouldn't work for rendering the vehicle cards which, for some reason, would only
appear when I used push to add elements to the array. I meant to convert this to an Observable and ran out of time. This basically
explains why there are currently two arrays of the same vehicle object, where one is using concat and the other push to add elements.

## Requirements

### Car Next Door - Take-home Programming Assignment
CND has expanded to the moon. We have the tools for tracking cars on Earth, but with our recent launch to the
moon, we need a tool for the CND Command Centre and Field Crews to be able to locate lunar vehicles. We currently have 6 vehicles - numbered 0,1,2,3,4 and 5. 

You can find their lunar GPS coordinates and other information using our LunarLocation JSON API:

Calling:

cndlunarlocator.herokuapp.com/vehicles/0/locate.json

Returns:

```JSON
{
    vehicle_id: 0,
    lat: -88.57913126391475,
    long: 79.21747437674591,
    name: "Heuvos Rancheros",
    model: "Rover TX 5",
    power_level_percent: 85
}
```

### The Task
The task is to create a javascript-based web front-end that allows CND staff to choose from the 6 vehicles and obtain their location by calling the API specified
above. The tool should also accept manual input of lunar lat/long to:
     
1. Show where the vehicle is on the lunar map; and       
2. Calculate the distance from the CND Command Centre (located at the Apollo 11 landing site at lat:0.681400, long: 23.460550) to the vehicle or coordinates
supplied. CND Staff are notoriously fickle and won&#39;t use a tool that is difficult to use or difficult to look at. This behavior costs the business millions in inefficiencies, as 
the staff will wander around aimlessly looking for cars based purely on “gut-feel”. 

### Submission

Please provide access to a running instance plus access to a private git repository. If you’re using github, please grant access to davetrumbull, amayvs,
amandagracewall and djpalmer88.

### What we’re looking for:
Clean, functional design with compatibility on recent browsers and working on mobile and desktop. Well-structured code with test cases as appropriate. We’ll also be looking at your commit history.

### Notes
Secure login to the tool is not required.

The Google Earth plugin has been deprecated. Check out Google Maps.

[Google Maps](https://developers.google.com/maps/documentation/javascript/examples/maptype-image)

If you’re restricted by time, outline further changes/enhancements you’d like to
make.

Feel free to ask any questions.

## Running Instructions (generated by [Angular CLI](https://github.com/angular/angular-cli))

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 1.7.2.

### Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The app will automatically reload if you change any of the source files.

### Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

### Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory. Use the `-prod` flag for a production build.

### Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

### Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via [Protractor](http://www.protractortest.org/).

### Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI README](https://github.com/angular/angular-cli/blob/master/README.md).
